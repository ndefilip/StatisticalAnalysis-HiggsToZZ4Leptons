// -------------------------------------------------------------------------
// double m4lmelamet(double f_mass4l,
//                   double f_D_bkg_kin,
//                   double f_pfmet)
//
// To compile in PyROOT:
//   code = open(filename).read()  # read code
//   gROOT.ProcessLine(code)       # compile code
//      :    :
//   D = m4lmelamet(...)
//
// created: Wed Feb  8 09:45:23 2017
// -------------------------------------------------------------------------
//
//
// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.0         [262656]
ROOT Release   : 5.34/28       [336412]
Creator        : dustin
Date           : Wed Feb  8 09:43:09 2017
Host           : Linux ec-ubuntu-14-04-x86-64-2 3.13.0-37-generic #64-Ubuntu SMP Mon Sep 22 21:28:38 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/dustin/Research/MonoHiggs/MVA
Training events: 20000
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
NTrees: "100" [Number of trees in the forest]
MinNodeSize: "1.0" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "100" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MaxDepth: "3" [Max depth of the decision tree allowed]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 3
f_mass4l                      f_mass4l                      f_mass4l                      f_mass4l                                                        'D'    [70.087677002,1526.62524414]
f_D_bkg_kin                   f_D_bkg_kin                   f_D_bkg_kin                   f_D_bkg_kin                                                     'D'    [1.75957006832e-06,0.996460556984]
f_pfmet                       f_pfmet                       f_pfmet                       f_pfmet                                                         'D'    [0.12551432848,1092.82128906]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

namespace {
class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 3 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "f_mass4l", "f_D_bkg_kin", "f_pfmet" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;

      // initialize input variable types
      fType[0] = 'D';
      fType[1] = 'D';
      fType[2] = 'D';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[3];
   double fVmax[3];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[3];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1.56547981303973);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 32.5818, 0, 1, 0.937686,-99) , 
NN(
0, 
0, 
-1, 46.1149, 0, -1, 0.0952384,-99) , 
0, 108.6, 0, 0, 0.82571,-99) , 
NN(
0, 
0, 
-1, 56.4763, 0, -1, 0.00401945,-99) , 
0, 142.193, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(1.14192);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.081499, 0, 1, 0.979498,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.288679,-99) , 
0, 150.99, 1, 0, 0.955031,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54301,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.101126,-99) , 
0, 117.71, 0, 0, 0.377278,-99) , 
NN(
0, 
0, 
-1, 142.434, 1, -1, 0.0104621,-99) , 
0, 128.579, 1, 0, 0.152461,-99) , 
2, 54.2194, 0, 0, 0.461805,-99)    );
  // itree = 2
  fBoostWeights.push_back(1.05631);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 94.9717, 0, 1, 0.984899,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.814189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.0956997,-99) , 
0, 129.735, 1, 0, 0.681846,-99) , 
2, 74.7914, 0, 0, 0.918094,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.153365,-99) , 
2, 33.3235, 0, 0, 0.265641,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 142.992, 1, 0, 0.154164,-99) , 
2, 54.2194, 0, 0, 0.415846,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.725965);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 95.5721, 0, 1, 0.933797,-99) , 
NN(
0, 
0, 
-1, 142.992, 1, -1, 0.232561,-99) , 
2, 65.0381, 0, 0, 0.413211,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.557528);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 110.975, 0, 1, 0.92948,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.368323,-99) , 
1, 0.471635, 0, 0, 0.51292,-99) , 
2, 75.8569, 0, 0, 0.611398,-99) , 
NN(
0, 
0, 
-1, 56.4763, 0, -1, 0.0151293,-99) , 
0, 171.036, 1, 0, 0.496839,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.417777);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 127.484, 1, 1, 0.976598,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550465,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.142427,-99) , 
0, 95.4961, 0, 0, 0.506541,-99) , 
2, 97.4944, 0, 0, 0.576154,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516923,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.0395175,-99) , 
0, 156.615, 1, 0, 0.482981,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.453631);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 96.6502, 0, 1, 0.895494,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36865,-99) , 
2, 45.5354, 0, 0, 0.420411,-99) , 
NN(
0, 
0, 
-1, 52.3462, 0, -1, 0.0126094,-99) , 
0, 142.992, 1, 0, 0.348746,-99) , 
2, 86.6757, 0, 0, 0.422333,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.261663);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 127.484, 1, 1, 0.945825,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.211626,-99) , 
0, 95.4961, 0, 0, 0.475769,-99) , 
2, 97.4944, 0, 0, 0.526623,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.0386763,-99) , 
0, 156.615, 1, 0, 0.461524,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.316915);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.148217, 0, 1, 0.900273,-99) , 
NN(
0, 
0, 
-1, 157.405, 1, -1, 0.371915,-99) , 
2, 97.4944, 0, 0, 0.420972,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.241873);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 117.228, 0, 1, 0.907616,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372032,-99) , 
2, 14.5861, 0, 0, 0.505334,-99) , 
2, 97.4944, 0, 0, 0.540399,-99) , 
NN(
0, 
0, 
-1, 56.4763, 0, -1, 0.0811986,-99) , 
0, 142.193, 1, 0, 0.484192,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.20589);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 127.929, 1, 1, 0.849923,-99) , 
NN(
0, 
0, 
-1, 94.7045, 0, -1, 0.460338,-99) , 
2, 97.4944, 0, 0, 0.493383,-99) , 
NN(
0, 
0, 
-1, 50.2197, 0, -1, 0.0470656,-99) , 
0, 171.036, 1, 0, 0.452396,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.191912);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 127.929, 1, 1, 0.821729,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331548,-99) , 
0, 94.7045, 0, 0, 0.511724,-99) , 
2, 97.4944, 0, 0, 0.536467,-99) , 
NN(
0, 
0, 
-1, 50.2197, 0, -1, 0.05721,-99) , 
0, 171.036, 1, 0, 0.495696,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.201344);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 146.791, 0, 1, 0.839008,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424314,-99) , 
1, 0.540477, 1, 0, 0.472283,-99) , 
2, 97.4944, 0, 0, 0.498316,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.0900227,-99) , 
0, 156.615, 1, 0, 0.462062,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.155612);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 117.228, 0, 1, 0.809051,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.307601,-99) , 
1, 0.188955, 0, 0, 0.475528,-99) , 
2, 97.4944, 0, 0, 0.497754,-99) , 
NN(
0, 
0, 
-1, 56.4763, 0, -1, 0.117396,-99) , 
0, 142.193, 1, 0, 0.461071,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.222164);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 146.791, 0, 1, 0.785837,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532524,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417928,-99) , 
1, 0.746785, 0, 0, 0.444208,-99) , 
2, 97.4944, 0, 0, 0.466236,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.101636,-99) , 
0, 156.615, 1, 0, 0.437525,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.12448);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 158.593, 0, 1, 0.79286,-99) , 
NN(
0, 
0, 
-1, 0.0889255, 0, -1, 0.475355,-99) , 
2, 129.951, 0, 0, 0.488879,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 56.4763, 0, 0, 0.0959068,-99) , 
0, 171.036, 1, 0, 0.46352,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.119643);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 169.059, 1, 1, 0.793233,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.289755,-99) , 
0, 137.021, 1, 0, 0.506991,-99) , 
2, 140.77, 0, 0, 0.517389,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 56.4763, 0, 0, 0.0951085,-99) , 
0, 171.036, 1, 0, 0.491418,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.104766);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.494709, 0, 1, 0.772921,-99) , 
NN(
0, 
0, 
-1, 0.0889255, 0, -1, 0.4797,-99) , 
2, 140.77, 0, 0, 0.490022,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542669,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 56.4763, 0, 0, 0.0942566,-99) , 
0, 171.036, 1, 0, 0.466764,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.161391);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.775239,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452596,-99) , 
1, 0.347681, 0, 0, 0.669072,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445633,-99) , 
2, 34.3971, 1, 0, 0.499939,-99) , 
2, 86.6757, 0, 0, 0.514391,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 56.4763, 0, 0, 0.0934369,-99) , 
0, 171.036, 1, 0, 0.490612,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.154693);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.69781,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.366937,-99) , 
0, 111.972, 0, 0, 0.641321,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533756,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449605,-99) , 
1, 0.540394, 1, 0, 0.491821,-99) , 
2, 75.8569, 0, 0, 0.508344,-99) , 
NN(
0, 
0, 
-1, 56.4763, 0, -1, 0.0920275,-99) , 
0, 171.036, 1, 0, 0.486102,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.120737);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.614635,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488977,-99) , 
2, 54.2194, 0, 0, 0.516374,-99) , 
NN(
0, 
0, 
-1, 0.0474475, 1, -1, 0.306622,-99) , 
1, 0.0889255, 0, 0, 0.505469,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 56.4763, 0, 0, 0.105795,-99) , 
0, 171.036, 1, 0, 0.485221,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.136976);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555771,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480329,-99) , 
0, 122.036, 0, 0, 0.533511,-99) , 
NN(
0, 
0, 
-1, 0.0474475, 1, -1, 0.332872,-99) , 
1, 0.0889255, 0, 0, 0.523271,-99) , 
NN(
0, 
0, 
-1, 56.4763, 0, -1, 0.104459,-99) , 
0, 171.036, 1, 0, 0.502931,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.149961);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550282,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443387,-99) , 
1, 0.317618, 0, 0, 0.52672,-99) , 
NN(
0, 
0, 
-1, 30.1903, 0, -1, 0.371799,-99) , 
0, 130.028, 1, 0, 0.5118,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518958,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 56.4763, 0, 0, 0.117984,-99) , 
0, 171.036, 1, 0, 0.493539,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0896366);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490574,-99) , 
0, 118.999, 1, 0, 0.506701,-99) , 
NN(
0, 
0, 
-1, 7.07787, 0, -1, 0.405085,-99) , 
2, 10.9443, 0, 0, 0.496464,-99) , 
NN(
0, 
0, 
-1, 56.4763, 0, -1, 0.115933,-99) , 
0, 171.036, 1, 0, 0.479664,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0826762);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 118.369, 1, 1, 0.519885,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39533,-99) , 
0, 95.0628, 0, 0, 0.51053,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503886,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 56.4763, 0, 0, 0.125441,-99) , 
0, 171.036, 1, 0, 0.494048,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0663744);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.639545,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492984,-99) , 
2, 119.132, 0, 0, 0.499132,-99) , 
NN(
0, 
0, 
-1, 0.326728, 1, -1, 0.352115,-99) , 
0, 137.021, 1, 0, 0.492961,-99) , 
NN(
0, 
0, 
-1, 56.4763, 0, -1, 0.12412,-99) , 
0, 171.036, 1, 0, 0.477612,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0964208);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534941,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47809,-99) , 
1, 0.671797, 1, 0, 0.51434,-99) , 
NN(
0, 
0, 
-1, 0.326728, 1, -1, 0.367401,-99) , 
0, 137.021, 1, 0, 0.508225,-99) , 
NN(
0, 
0, 
-1, 56.4763, 0, -1, 0.131517,-99) , 
0, 171.036, 1, 0, 0.492906,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0928766);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521149,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40008,-99) , 
0, 95.0425, 0, 0, 0.512087,-99) , 
NN(
0, 
0, 
-1, 7.07787, 0, -1, 0.420597,-99) , 
2, 10.9443, 0, 0, 0.502883,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55943,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.142927,-99) , 
0, 171.036, 1, 0, 0.488699,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0916898);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478344,-99) , 
0, 118.04, 1, 0, 0.492858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369568,-99) , 
1, 0.079061, 0, 0, 0.487435,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536429,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.141378,-99) , 
0, 171.036, 1, 0, 0.474233,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.146843);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486801,-99) , 
1, 0.483506, 1, 0, 0.522953,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39512,-99) , 
1, 0.708751, 0, 0, 0.461231,-99) , 
0, 123.035, 0, 0, 0.502127,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.139739,-99) , 
0, 171.036, 1, 0, 0.488724,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0973847);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528583,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404545,-99) , 
0, 132.026, 1, 0, 0.522037,-99) , 
NN(
0, 
0, 
-1, 122.936, 0, -1, 0.430782,-99) , 
1, 0.187571, 0, 0, 0.510008,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.136873,-99) , 
0, 171.036, 1, 0, 0.49681,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0644377);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.651514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463349,-99) , 
1, 0.385302, 0, 0, 0.580222,-99) , 
NN(
0, 
0, 
-1, 6.12304, 0, -1, 0.48628,-99) , 
2, 86.6757, 0, 0, 0.493821,-99) , 
NN(
0, 
0, 
-1, 43.9631, 0, -1, 0.134391,-99) , 
0, 185.457, 1, 0, 0.482458,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.127811);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547528,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467406,-99) , 
2, 19.9892, 0, 0, 0.527753,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537618,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378188,-99) , 
0, 118.841, 1, 0, 0.471246,-99) , 
0, 123.035, 0, 0, 0.50882,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516253,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.156584,-99) , 
0, 171.036, 1, 0, 0.497001,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0623451);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591925,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493013,-99) , 
2, 75.8569, 0, 0, 0.502799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409823,-99) , 
0, 95.2126, 0, 0, 0.495807,-99) , 
NN(
0, 
0, 
-1, 43.9631, 0, -1, 0.139277,-99) , 
0, 185.457, 1, 0, 0.485189,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.096616);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.649878,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490237,-99) , 
2, 24.8654, 0, 0, 0.535112,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507208,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331028,-99) , 
0, 102.997, 0, 0, 0.483962,-99) , 
2, 32.5818, 1, 0, 0.509021,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.160439,-99) , 
0, 171.036, 1, 0, 0.498,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0954217);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 25.508, 0, 1, 0.544746,-99) , 
NN(
0, 
0, 
-1, 104.328, 0, -1, 0.466442,-99) , 
2, 32.5818, 1, 0, 0.504751,-99) , 
NN(
0, 
0, 
-1, 43.9631, 0, -1, 0.159448,-99) , 
0, 185.457, 1, 0, 0.494977,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0596218);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613579,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509186,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372356,-99) , 
0, 102.853, 0, 0, 0.500163,-99) , 
0, 90.6444, 1, 0, 0.505284,-99) , 
NN(
0, 
0, 
-1, 43.9631, 0, -1, 0.172656,-99) , 
0, 185.457, 1, 0, 0.496133,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0689717);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512497,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457151,-99) , 
1, 0.317618, 0, 0, 0.500272,-99) , 
NN(
0, 
0, 
-1, 30.1903, 0, -1, 0.41968,-99) , 
0, 130.028, 1, 0, 0.492652,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556548,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.194608,-99) , 
0, 171.036, 1, 0, 0.483848,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0568271);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608573,-99) , 
NN(
0, 
0, 
-1, 130.028, 1, -1, 0.482775,-99) , 
1, 0.947138, 0, 0, 0.485544,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539466,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.192477,-99) , 
0, 171.036, 1, 0, 0.477073,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0412036);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607251,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497719,-99) , 
0, 90.6056, 1, 0, 0.502781,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.18622,-99) , 
1, 0.326728, 1, 0, 0.412928,-99) , 
0, 137.021, 1, 0, 0.499121,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.190645,-99) , 
0, 171.036, 1, 0, 0.490361,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0636151);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532555,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492415,-99) , 
2, 32.5818, 1, 0, 0.512132,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.192545,-99) , 
1, 0.326728, 1, 0, 0.408891,-99) , 
0, 137.021, 1, 0, 0.507945,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.189274,-99) , 
0, 171.036, 1, 0, 0.49901,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0674125);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526852,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485062,-99) , 
0, 123.037, 0, 0, 0.512427,-99) , 
NN(
0, 
0, 
-1, 0.326728, 1, -1, 0.402589,-99) , 
0, 137.021, 1, 0, 0.507996,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.187084,-99) , 
0, 171.036, 1, 0, 0.499164,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.142468);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.657111,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.355206,-99) , 
1, 0.385187, 0, 0, 0.552218,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461142,-99) , 
1, 0.424319, 1, 0, 0.49255,-99) , 
0, 118.04, 1, 0, 0.503676,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515985,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.197553,-99) , 
0, 171.036, 1, 0, 0.49541,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0802157);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529777,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477161,-99) , 
1, 0.317618, 0, 0, 0.518258,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514217,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.335962,-99) , 
2, 30.1903, 0, 0, 0.439118,-99) , 
0, 130.028, 1, 0, 0.510844,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.192102,-99) , 
0, 171.036, 1, 0, 0.502539,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0320824);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 90.6056, 1, 1, 0.50472,-99) , 
NN(
0, 
0, 
-1, 28.5646, 0, -1, 0.395118,-99) , 
0, 137.021, 1, 0, 0.500338,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500427,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.20486,-99) , 
0, 171.036, 1, 0, 0.492805,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0748771);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441673,-99) , 
0, 119.026, 0, 0, 0.52007,-99) , 
NN(
0, 
0, 
-1, 138.951, 1, -1, 0.478054,-99) , 
2, 43.4006, 0, 0, 0.492629,-99) , 
NN(
0, 
0, 
-1, 43.9631, 0, -1, 0.189945,-99) , 
0, 185.457, 1, 0, 0.485644,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0780338);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602925,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.357151,-99) , 
2, 54.7491, 1, 0, 0.543939,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503773,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372438,-99) , 
0, 121.198, 0, 0, 0.492344,-99) , 
0, 118.04, 1, 0, 0.501808,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.213782,-99) , 
0, 171.036, 1, 0, 0.494678,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0891656);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400589,-99) , 
1, 0.385187, 0, 0, 0.534099,-99) , 
NN(
0, 
0, 
-1, 121.198, 0, -1, 0.476212,-99) , 
0, 118.04, 1, 0, 0.486763,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.210233,-99) , 
0, 171.036, 1, 0, 0.480053,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0511515);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51277,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428874,-99) , 
0, 92.5912, 0, 0, 0.507778,-99) , 
NN(
0, 
0, 
-1, 0.326728, 1, -1, 0.406638,-99) , 
0, 137.021, 1, 0, 0.503777,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509641,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.22542,-99) , 
0, 171.036, 1, 0, 0.497171,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0426952);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.678332,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494426,-99) , 
1, 0.0716607, 1, 0, 0.498887,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507774,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.354711,-99) , 
0, 133.68, 0, 0, 0.440792,-99) , 
0, 130.028, 1, 0, 0.493458,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.222883,-99) , 
0, 171.036, 1, 0, 0.487122,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0399118);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0716607, 1, 1, 0.509045,-99) , 
NN(
0, 
0, 
-1, 133.68, 0, -1, 0.439285,-99) , 
0, 130.028, 1, 0, 0.502541,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.230366,-99) , 
0, 171.036, 1, 0, 0.496237,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0327003);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607354,-99) , 
NN(
0, 
0, 
-1, 130.028, 1, -1, 0.491853,-99) , 
1, 0.947138, 0, 0, 0.494422,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.228288,-99) , 
0, 171.036, 1, 0, 0.48832,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.025499);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60897,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499517,-99) , 
0, 90.6424, 1, 0, 0.504075,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349899,-99) , 
0, 147.011, 1, 0, 0.502233,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505725,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.2341,-99) , 
0, 171.036, 1, 0, 0.496137,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0349596);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548333,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499884,-99) , 
1, 0.297007, 1, 0, 0.50992,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.355721,-99) , 
0, 147.011, 1, 0, 0.508084,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.232724,-99) , 
0, 171.036, 1, 0, 0.501866,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.049473);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 146.012, 0, 1, 0.516946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433979,-99) , 
1, 0.079061, 0, 0, 0.513252,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508089,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.239025,-99) , 
0, 171.036, 1, 0, 0.507112,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0372632);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598077,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503902,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40645,-99) , 
0, 102.853, 0, 0, 0.497599,-99) , 
0, 90.6444, 1, 0, 0.501717,-99) , 
NN(
0, 
0, 
-1, 0.300542, 1, -1, 0.22349,-99) , 
0, 185.457, 1, 0, 0.496112,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0491494);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.63322,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493953,-99) , 
0, 120.397, 1, 0, 0.523294,-99) , 
NN(
0, 
0, 
-1, 0.668032, 1, -1, 0.48488,-99) , 
1, 0.749848, 0, 0, 0.493829,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502935,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.241595,-99) , 
0, 171.036, 1, 0, 0.488296,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0272376);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 90.6424, 1, 1, 0.506597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.362842,-99) , 
0, 147.011, 1, 0, 0.504913,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.238724,-99) , 
0, 171.036, 1, 0, 0.499142,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0271538);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.610307,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501491,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44499,-99) , 
0, 130.028, 1, 0, 0.496281,-99) , 
1, 0.957003, 0, 0, 0.498263,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.243709,-99) , 
0, 171.036, 1, 0, 0.492782,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0401686);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60383,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59795,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488449,-99) , 
1, 0.0475113, 1, 0, 0.490743,-99) , 
1, 0.957003, 0, 0, 0.492703,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504246,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.248749,-99) , 
0, 171.036, 1, 0, 0.487485,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0331689);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62396,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498367,-99) , 
0, 109.349, 1, 0, 0.505658,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450833,-99) , 
0, 95.0628, 0, 0, 0.501984,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.24628,-99) , 
0, 171.036, 1, 0, 0.496566,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0396308);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 109.349, 1, 1, 0.512991,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459058,-99) , 
0, 95.0628, 0, 0, 0.509381,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502496,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.252489,-99) , 
0, 171.036, 1, 0, 0.503981,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0413435);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.640707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391725,-99) , 
1, 0.379475, 0, 0, 0.551927,-99) , 
NN(
0, 
0, 
-1, 0.0494675, 0, -1, 0.495647,-99) , 
0, 102.056, 1, 0, 0.500801,-99) , 
NN(
0, 
0, 
-1, 62.733, 0, -1, 0.249963,-99) , 
0, 171.036, 1, 0, 0.495576,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0578709);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587941,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414953,-99) , 
1, 0.809533, 1, 0, 0.547606,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.366665,-99) , 
2, 68.3332, 1, 0, 0.505358,-99) , 
2, 75.8569, 0, 0, 0.509924,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502924,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
2, 62.733, 0, 0, 0.257794,-99) , 
0, 171.036, 1, 0, 0.504722,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0961489);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.563338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.343481,-99) , 
0, 110.975, 0, 0, 0.525429,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475265,-99) , 
0, 107.583, 1, 0, 0.489091,-99) , 
2, 54.2194, 0, 0, 0.497285,-99) , 
NN(
0, 
0, 
-1, 265.003, 0, -1, 0.253939,-99) , 
0, 171.036, 1, 0, 0.492327,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0402025);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 118.438, 1, 1, 0.513036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441782,-99) , 
0, 95.2126, 0, 0, 0.508308,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.260216,-99) , 
0, 185.457, 1, 0, 0.50381,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0242212);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497492,-99) , 
0, 90.6424, 1, 0, 0.501486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356842,-99) , 
0, 147.011, 1, 0, 0.499812,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.278919,-99) , 
0, 171.036, 1, 0, 0.495431,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0252994);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 90.6424, 1, 1, 0.507044,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36242,-99) , 
0, 147.011, 1, 0, 0.505376,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.283817,-99) , 
0, 171.036, 1, 0, 0.501004,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0299714);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.582576,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501976,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397587,-99) , 
0, 102.853, 0, 0, 0.49548,-99) , 
0, 90.6444, 1, 0, 0.499001,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.277856,-99) , 
0, 185.457, 1, 0, 0.49507,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.034508);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490673,-99) , 
0, 90.6424, 1, 0, 0.494132,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361341,-99) , 
0, 147.011, 1, 0, 0.492599,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.293882,-99) , 
0, 171.036, 1, 0, 0.488718,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.038657);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495369,-99) , 
0, 118.369, 1, 0, 0.504656,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441485,-99) , 
0, 95.0628, 0, 0, 0.500528,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.301093,-99) , 
0, 171.036, 1, 0, 0.496659,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0357016);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550671,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499937,-99) , 
1, 0.749848, 0, 0, 0.511943,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451037,-99) , 
0, 95.0628, 0, 0, 0.507969,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.30929,-99) , 
0, 171.036, 1, 0, 0.504141,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0508759);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584977,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515733,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417622,-99) , 
0, 102.853, 0, 0, 0.509718,-99) , 
0, 90.6444, 1, 0, 0.512767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.306553,-99) , 
0, 185.457, 1, 0, 0.5092,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0345296);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538878,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4939,-99) , 
1, 0.297007, 1, 0, 0.503235,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372411,-99) , 
0, 147.011, 1, 0, 0.501736,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.325757,-99) , 
0, 171.036, 1, 0, 0.498391,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0308524);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 141.017, 0, 1, 0.510117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435874,-99) , 
1, 0.079061, 0, 0, 0.50683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.333386,-99) , 
0, 171.036, 1, 0, 0.503551,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0216001);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571614,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50107,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428243,-99) , 
0, 102.853, 0, 0, 0.496609,-99) , 
0, 90.6444, 1, 0, 0.499647,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331807,-99) , 
0, 185.457, 1, 0, 0.496798,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0397277);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.611017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452433,-99) , 
1, 0.447085, 0, 0, 0.542298,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500743,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451652,-99) , 
0, 121.871, 0, 0, 0.490975,-99) , 
0, 101.784, 1, 0, 0.495585,-99) , 
NN(
0, 
0, 
-1, 0.300542, 1, -1, 0.367622,-99) , 
0, 156.615, 1, 0, 0.492204,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0511219);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.613674,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409863,-99) , 
1, 0.379475, 0, 0, 0.538482,-99) , 
NN(
0, 
0, 
-1, 0.0494111, 0, -1, 0.484662,-99) , 
0, 102.065, 1, 0, 0.489463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.345541,-99) , 
0, 185.457, 1, 0, 0.487042,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0270065);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617565,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498127,-99) , 
0, 109.506, 1, 0, 0.504699,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444,-99) , 
0, 95.2126, 0, 0, 0.500803,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.357191,-99) , 
0, 185.457, 1, 0, 0.498404,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0304872);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 118.438, 1, 1, 0.510709,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450677,-99) , 
0, 95.2126, 0, 0, 0.506861,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.363416,-99) , 
0, 185.457, 1, 0, 0.504473,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0304396);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424027,-99) , 
1, 0.379475, 0, 0, 0.542001,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.323488,-99) , 
1, 0.0494675, 0, 0, 0.496297,-99) , 
0, 102.056, 1, 0, 0.500341,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.376867,-99) , 
0, 171.036, 1, 0, 0.498065,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0515738);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.71742,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441451,-99) , 
2, 205.648, 0, 0, 0.512401,-99) , 
2, 169.059, 1, 0, 0.572904,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474379,-99) , 
2, 33.5409, 1, 0, 0.493467,-99) , 
NN(
0, 
0, 
-1, 0.271458, 1, -1, 0.262415,-99) , 
0, 156.615, 1, 0, 0.488426,-99) , 
2, 140.77, 0, 0, 0.491551,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0501781);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 96.1773, 1, 1, 0.581172,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569891,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.279809,-99) , 
2, 99.7336, 0, 0, 0.399432,-99) , 
1, 0.799195, 1, 0, 0.540332,-99) , 
NN(
0, 
0, 
-1, 142.992, 1, -1, 0.484517,-99) , 
2, 75.8569, 0, 0, 0.490963,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0503949);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584554,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448464,-99) , 
1, 0.385187, 0, 0, 0.537539,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504372,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.393345,-99) , 
0, 121.169, 0, 0, 0.495893,-99) , 
0, 118.918, 1, 0, 0.503512,-99) , 
NN(
0, 
0, 
-1, 0.300542, 1, -1, 0.403957,-99) , 
0, 156.615, 1, 0, 0.500992,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0756782);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.104618, 0, 1, 0.606678,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.71613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481925,-99) , 
1, 0.914426, 0, 0, 0.492384,-99) , 
1, 0.167792, 1, 0, 0.510357,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46425,-99) , 
2, 24.9336, 0, 0, 0.490511,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 142.992, 1, 0, 0.482383,-99) , 
2, 43.4006, 0, 0, 0.492107,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0591749);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.743754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487911,-99) , 
1, 0.104618, 0, 0, 0.588482,-99) , 
NN(
0, 
0, 
-1, 0.914426, 0, 1, 0.509625,-99) , 
1, 0.167792, 1, 0, 0.521962,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421102,-99) , 
2, 34.3436, 1, 0, 0.491974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
0, 142.992, 1, 0, 0.484107,-99) , 
2, 43.4006, 0, 0, 0.497265,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0542534);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.104618, 0, 1, 0.592206,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.687937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486046,-99) , 
1, 0.914426, 0, 0, 0.494833,-99) , 
1, 0.167792, 1, 0, 0.509995,-99) , 
NN(
0, 
0, 
-1, 142.992, 1, -1, 0.475795,-99) , 
2, 43.4006, 0, 0, 0.487686,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0635176);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.296942, 1, 1, 0.554063,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.334902,-99) , 
1, 0.0691413, 0, 0, 0.497888,-99) , 
0, 123.783, 1, 0, 0.518368,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512136,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438183,-99) , 
2, 34.1303, 1, 0, 0.495709,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54102,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.176246,-99) , 
1, 0.541069, 0, 0, 0.352379,-99) , 
2, 6.11621, 0, 0, 0.489341,-99) , 
2, 43.4006, 0, 0, 0.499431,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0480457);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568746,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511361,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474145,-99) , 
1, 0.424285, 1, 0, 0.487287,-99) , 
0, 90.6444, 1, 0, 0.490504,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.387926,-99) , 
0, 185.457, 1, 0, 0.488931,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0538654);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654265,-99) , 
NN(
0, 
0, 
-1, 0.349248, 0, -1, 0.495095,-99) , 
1, 0.32942, 1, 0, 0.499928,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383214,-99) , 
2, 20.3804, 0, 0, 0.500286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.207401,-99) , 
1, 0.3032, 1, 0, 0.467968,-99) , 
1, 0.315711, 0, 0, 0.491976,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0605176);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.641981,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511695,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331923,-99) , 
1, 0.349248, 0, 0, 0.508561,-99) , 
1, 0.32942, 1, 0, 0.51258,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521169,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.396023,-99) , 
2, 20.3804, 0, 0, 0.492905,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.216396,-99) , 
1, 0.3032, 1, 0, 0.462745,-99) , 
1, 0.315711, 0, 0, 0.500215,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0655359);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.627956,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488485,-99) , 
0, 98.93, 1, 0, 0.493958,-99) , 
1, 0.32942, 1, 0, 0.497965,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56455,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453811,-99) , 
1, 0.219145, 0, 0, 0.484575,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.226833,-99) , 
1, 0.3032, 1, 0, 0.456833,-99) , 
1, 0.315711, 0, 0, 0.487781,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0672621);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.369512, 1, 1, 0.521035,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505387,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.27654,-99) , 
0, 117.281, 0, 0, 0.459634,-99) , 
2, 65.0381, 1, 0, 0.511168,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.626651,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47653,-99) , 
1, 0.0480331, 1, 0, 0.491825,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.238532,-99) , 
1, 0.3032, 1, 0, 0.464918,-99) , 
1, 0.315711, 0, 0, 0.499749,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0371455);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58229,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.807203,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403528,-99) , 
1, 0.0281173, 0, 0, 0.610719,-99) , 
NN(
0, 
0, 
-1, 0.0744762, 0, -1, 0.486889,-99) , 
1, 0.0473752, 1, 0, 0.489701,-99) , 
1, 0.956997, 0, 0, 0.491278,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0335782);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575497,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496431,-99) , 
0, 118.438, 1, 0, 0.505972,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435597,-99) , 
0, 95.2126, 0, 0, 0.501543,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40165,-99) , 
0, 185.457, 1, 0, 0.500034,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0324683);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 109.506, 1, 1, 0.512345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44387,-99) , 
0, 95.2126, 0, 0, 0.508042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409746,-99) , 
0, 185.457, 1, 0, 0.506562,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0330485);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.698062,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55147,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437476,-99) , 
2, 205.648, 0, 0, 0.495951,-99) , 
2, 169.059, 1, 0, 0.55457,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505882,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428251,-99) , 
0, 92.3306, 0, 0, 0.50175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.29213,-99) , 
0, 156.615, 1, 0, 0.49756,-99) , 
2, 140.77, 0, 0, 0.499694,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0425546);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.692929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485539,-99) , 
2, 96.1773, 1, 0, 0.561614,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.290369,-99) , 
2, 99.7336, 0, 0, 0.398817,-99) , 
1, 0.799195, 1, 0, 0.525664,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401179,-99) , 
2, 63.0864, 1, 0, 0.493086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.234952,-99) , 
0, 142.992, 1, 0, 0.488473,-99) , 
2, 75.8569, 0, 0, 0.492791,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0659798);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.683801,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496174,-99) , 
2, 96.1773, 1, 0, 0.564667,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538454,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.299215,-99) , 
2, 99.7336, 0, 0, 0.399928,-99) , 
1, 0.799195, 1, 0, 0.528364,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.646786,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480479,-99) , 
2, 69.8322, 0, 0, 0.483957,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.242688,-99) , 
0, 142.992, 1, 0, 0.479692,-99) , 
2, 75.8569, 0, 0, 0.485325,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0429606);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.70593,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.562712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467295,-99) , 
2, 205.648, 0, 0, 0.51662,-99) , 
2, 169.059, 1, 0, 0.572331,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512765,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481167,-99) , 
2, 25.1871, 0, 0, 0.500808,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.298309,-99) , 
0, 156.615, 1, 0, 0.496949,-99) , 
2, 140.77, 0, 0, 0.499774,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }

// Instantiate an MLP object
std::string ivars[] = {"f_mass4l",
                       "f_D_bkg_kin",
                       "f_pfmet"};
std::vector<std::string> iivars(ivars, ivars + 3);
ReadBDT mlp(iivars);
};

double m4lmelamet(double f_mass4l,
                  double f_D_bkg_kin,
                  double f_pfmet)
{
  std::vector<double> inputvars(3);
  inputvars[0]	= f_mass4l;
  inputvars[1]	= f_D_bkg_kin;
  inputvars[2]	= f_pfmet;
  return mlp.GetMvaValue(inputvars);
}
    